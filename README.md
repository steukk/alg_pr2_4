Работа Штойк Валерии, УИБО-14-24
**Вариант 1**

# Рекурсивное вычисление суммы цифр числа

## Python

**Как работает алгоритм:**
- `def sum_digits(n):` — объявление функции с параметром n (число, для которого вычисляется сумма цифр).
- `if n < 10:` - базовый случай, возвращает само число (сумма цифр однозначного числа равна самому числу)
- `return n % 10 + sum_digits(n // 10)` - рекурсивный случай: последняя цифра числа + сумма цифр оставшейся части

**Временная сложность:** O(n)

**Почему такая сложность:** Рекурсия вызывается n раз, где n - количество цифр в числе, на каждом шаге обрабатывая одну цифру.

## Java

**Как работает алгоритм:**
- `public static int sumDigits(int n)` — метод с параметром n (целое число, для которого вычисляется сумма цифр).
- `if (n < 0)` - обработка отрицательных чисел, рекурсивно вызывается с положительным значением
- `if (n < 10)` - базовый случай, возвращает само число
- `return n % 10 + sumDigits(n / 10)` - рекурсивный случай: извлекает последнюю цифру и суммирует с результатом рекурсивного вызова

**Временная сложность:** O(n)

**Почему такая сложность:** Функция рекурсивно вызывается n раз, где n - количество цифр, уменьшая число на одну цифру на каждом шаге.

## C++

**Как работает алгоритм:**
- `int sumDigits(int n)` — объявление функции с параметром n (целое число, для которого вычисляется сумма цифр).
- `if (n < 10)` - базовый случай, возвращает само число
- `return n % 10 + sumDigits(n / 10)` - рекурсивный случай: последняя цифра + сумма цифр оставшейся части числа

**Временная сложность:** O(n)

**Почему такая сложность:** На каждом шаге обрабатывается одна цифра числа, поэтому количество рекурсивных вызовов равно количеству цифр n.

## Контрольный вопрос
**10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?**

**Обход в глубину (DFS)** и **обход в ширину (BFS)** — это два основных способа обхода дерева или графа, которые отличаются порядком посещения узлов.

**DFS** идет по одному пути от корня до самого конца, доходит до листа, затем возвращается к последней точке, где был выбор, и идет по следующей возможной ветке. Он погружается вглубь структуры, прежде чем исследовать соседние узлы на том же уровне.

**BFS** идет по уровням: сначала обрабатывает все узлы на текущей глубине (например, все дети корня), и только потом переходит к узлам следующего уровня (внукам). Он исследует структуру слоями, постепенно удаляясь от начальной точки.

**Главное практическое отличие:** BFS гарантированно находит кратчайший путь в невзвешенном графе, так как идет по уровням. DFS может быстрее найти целевой узел в глубоких структурах, но не гарантирует, что путь до него будет кратчайшим. BFS обычно требует больше памяти, так как хранит в очереди все узлы текущего уровня, а DFS (особенно рекурсивный) зависит от глубины структуры.
